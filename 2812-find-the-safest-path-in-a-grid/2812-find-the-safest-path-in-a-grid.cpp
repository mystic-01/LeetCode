class Solution {
public:
    int maximumSafenessFactor(vector<vector<int>>& grid) {
        int row = grid.size(), col = grid[0].size(), ans = INT_MIN;
        int offsets[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int offsetsMove[2][2] = {{0, 1}, {1, 0}};
        vector<vector<int>> distFromThief(row, vector<int>(col, INT_MAX));

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 1) {
                    queue<vector<int>> q;
                    q.push({i, j, 0});
                    grid[i][j] = -1;
                    distFromThief[i][j] = 0;
                    
                    while (!q.empty()) {
                        int x = q.front()[0], y = q.front()[1], dist = q.front()[2];
                        q.pop();
                        for (int k = 0; k < 4; k++) {
                            int a = x + offsets[k][0], b = y + offsets[k][1];    
                            if (a < row && a >= 0 && b < col && b >= 0 && distFromThief[a][b] > dist + 1) {
                                if (grid[a][b] == 1) {
                                    q.push({a, b, 0});
                                    grid[a][b] = -1;
                                    distFromThief[a][b] = 0;
                                } else {
                                    q.push({a, b, dist + 1});
                                    grid[a][b] = -1;
                                    distFromThief[a][b] = dist + 1;
                                };    
                            };
                        };
                    };
                };
            };
        };
        
        priority_queue<pair<int, pair<int, int>>> q;
        q.push({distFromThief[0][0], {0, 0}});
        while (!q.empty()) {
            int x = q.top().second.first, y = q.top().second.second, dist = q.top().first;
                q.pop();
                        
                if (x == row - 1 && y == col - 1) {
                    ans = max(ans, dist);
                    break;
                } else {
                    for (int k = 0; k < 4; k++) {
                        int a = x + offsets[k][0], b = y + offsets[k][1];    
                        if (a >= 0 && b >= 0 && a < row && b < col && distFromThief[a][b] != -1) {
                            q.push({min(dist, distFromThief[a][b]), {a, b}});
                            distFromThief[a][b] = -1;
                        };
                    };

                };
            };
        
        return ans;
    };
};

/*
[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
,[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
,[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0]
,[0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0]
,[0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0]
,[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]
,[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]
,[0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0]
,[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]
,[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]]

*/
